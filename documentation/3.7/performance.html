<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ehcache is fast. Really fast.
It was thought and made to be.
For example, a straight <code>get(key)</code> from the cache should be under 500ns.
That&#8217;s fast and way sufficient for most purpose.</p>
</div>
<div class="paragraph">
<p>Keep that in mind. Especially when comparing caching frameworks with a benchmark.
If something looks 10% faster it actually means 50ns faster.
Do you care that much about these 50ns to lose your precious time in benchmarking?</p>
</div>
<div class="paragraph">
<p>That said, the way you configure Ehcache can have an impact on performance.
This document is a work in progress.
It will give you the performance impact of classical Ehcache configuration.
It will also give you some advance tuning possibilities.</p>
</div>
<div class="paragraph">
<p>In the future, we will add some figures of what "slower" means.
However, always do your own benchmark.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stores"><a class="anchor" href="#stores"></a>Stores</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We probably know that the faster store is on-heap.
Until you overwhelm the garbage collector.</p>
</div>
<div class="paragraph">
<p>Your next best bet is off-heap.</p>
</div>
<div class="paragraph">
<p>Try to avoid disk.
Use a remote drive or even an HDD at your own risk.</p>
</div>
<div class="paragraph">
<p>We won&#8217;t talk about clustering here because it&#8217;s a different realm and its performance is based on many factors.</p>
</div>
<div class="paragraph">
<p>The next question would be: "Should I use a single tier?" Is using a single-tier off-heap faster than two-tiers?
The answer depends on what you do with it.
Having two tiers is a bit slower on writing.
It is also a bit slower on reading when the data is not found in the caching tier (on-heap).
However, it will be faster for an entry that is indeed found there.</p>
</div>
<div class="paragraph">
<p>So again, it depends.
The more you follow the caching hypothesis that the same data is always reused (and so in the caching
tier), the more interesting having two tiers will be.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="byte-sizing"><a class="anchor" href="#byte-sizing"></a>Byte Sizing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A on-heap tier can be limited to a number of entries or a number of bytes.
When using bytes, we need to calculate the size of every object added to the cache.
This is of course much slower than calculating the number of entries.</p>
</div>
<div class="paragraph">
<p>Size calculation is done using the <a href="https://github.com/ehcache/sizeof">SizeOf</a> library.
This library uses multiple magic tricks to do so. It selects the fastest one for a given environment.
Make sure of what is used to confirm you can&#8217;t use a faster way on your platform.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="serialization"><a class="anchor" href="#serialization"></a>Serialization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Off-heap, disk and clustering need to serialize keys and values before storing them.
By default, the Java serialization is used.
It is well-known for not being the fastest thing around.
Ehcache uses it because it is supported out of the box.
However, you can increase performances by provoding your own serializers.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="copier"><a class="anchor" href="#copier"></a>Copier</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, on-heap storage stores the entries by reference.
You might want to use a copier to store entries by value for whatever reason.
This can be much slower so watch out.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="loader-writer"><a class="anchor" href="#loader-writer"></a>Loader-Writer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Loader-writer is interesting for many reasons.
First, it protects you against the Thundering Herd.
However, it needs to pass through more complicated code to do so.</p>
</div>
<div class="paragraph">
<p>We are expecting it to be a tiny bit slower.
But nothing noticeable enough to prevent you from using it.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="expiration"><a class="anchor" href="#expiration"></a>Expiration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A cache with no expiration will always be faster.</p>
</div>
<div class="sect2">
<h3 id="time-to-live"><a class="anchor" href="#time-to-live"></a>Time to Live</h3>
<div class="paragraph">
<p>If you need to set an expiration time, TTL will be the faster one.
This is because the expiration time of an entry is calculated and updated ony when the entry is inserted or updated in the cache.
But it still requires an expiration check at access time.</p>
</div>
<div class="paragraph">
<p>So you can expect a 2% drop in performance when using TTL. Not bad.</p>
</div>
</div>
<div class="sect2">
<h3 id="time-to-idle"><a class="anchor" href="#time-to-idle"></a>Time to Idle</h3>
<div class="paragraph">
<p>TTI is slower than TTL.
We need to recalculate and update the expiration time each time the entry is accessed.</p>
</div>
</div>
<div class="sect2">
<h3 id="custom"><a class="anchor" href="#custom"></a>Custom</h3>
<div class="paragraph">
<p>In general, using a custom <code>ExpiryPolicy</code> will be the slowest.
Ehcache had optimised the handling to handle other cases.
When using a custom policy, you are on your own.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="allocation-rate"><a class="anchor" href="#allocation-rate"></a>Allocation rate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ehcache won&#8217;t allocate any object during a simple <code>get()</code>.
However, keep in mind that your configuration might do so.</p>
</div>
<div class="paragraph">
<p>For instance, let&#8217;s say you define an expiry policy like this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Unresolved directive in performance.adoc - include::_eh35/integration-test/src/test/java/org/ehcache/docs/Performance.java[tag=expiryAllocation]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Will instantiate a <code>Duration</code> every time an entry is accessed</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this case, putting the <code>Duration</code> as a constant would solve the problem.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="time-source"><a class="anchor" href="#time-source"></a>Time Source</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, Ehcache uses a <code>TimeSource</code> that will retrieve the system time at every call. It is fast but not super
duper fast. But it is super duper accurate.</p>
</div>
<div class="paragraph">
<p>You can trade accuracy for speed by using a <code>TickingTimeSource</code>. Please read the javadoc for details but the concept is
that a timer will increase time instead of always retrieving system time.</p>
</div>
<div class="paragraph">
<p>Switching to <code>TickingTimeSource</code>, even with a granularity of 1ms, can improve the performance of a <code>get</code> as high as 30%.</p>
</div>
<div class="paragraph">
<p>The drawback is that a timer will continuously run.
Also, time might drift from the real time a bit.
Especially if the granularity of the <code>systemUpdatePeriod</code> is big.
Is your expiration needs to be really tightly linked with real time, it can be a problem.
But in most cases, the drifting doesn&#8217;t matter much.</p>
</div>
</div>
</div>