<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In case of failures, Ehcache will do its best to do two things</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Keep a coherent state for every tier</p>
</li>
<li>
<p>Answer requests</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>No failures should occur from Ehcache itself. However, the surrounding environment can fail. e.g.:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Disk failure of a disk tier</p>
</li>
<li>
<p>Server loss of a clustered tier</p>
</li>
<li>
<p>Network failure of a clustered tier</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resilience-strategy"><a class="anchor" href="#resilience-strategy"></a>Resilience strategy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A cache provides an answer to the caller even if the underlying tiers fail to do so.
For instance, if the cache fails to <code>get()</code> a value, it will return <code>null</code>.</p>
</div>
<div class="paragraph">
<p>This behavior is handled by the <code>ResilienceStrategy</code>.
Each time a backend tier fails, it throws a <code>StoreAccessException</code> that is then handled by the resilience strategy.</p>
</div>
<div class="paragraph">
<p>Ehcache provides two implementations by default. One use by the classical cache called the <code>RobustResilienceStrategy</code> and one
for a cache with a <a href="writers.html">loader-writer</a> called the <code>RobustLoaderWriterResilienceStrategy</code>.</p>
</div>
<div class="paragraph">
<p>The <code>RobustResilienceStrategy</code> behaves like an always empty cache where everything added to it is immediately evicted.
The result is that the caller will more or less behave as if the cache was disabled.</p>
</div>
<div class="paragraph">
<p>The <code>RobustLoaderWriterResilienceStrategy</code> knows about the loader-writer and will try to keep it coherent.
It will also answer by calling it. So a <code>get()</code> will load the value from the loader-writer.
A <code>putIfAbsent()</code> will load the value from the loader-writer and see if it&#8217;s there.
If not, it will write it, if it is, it will return it.</p>
</div>
<div class="paragraph">
<p>Both strategies will also try to clean up the store that failed by removing the failed key or keys.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="clustering-resilience"><a class="anchor" href="#clustering-resilience"></a>Clustering resilience</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s be honest, your on-heap storage won&#8217;t fail. Your off-heap won&#8217;t either.
Your disk storage might, rarely, unless you used a network drive. But then, you are asking for it.</p>
</div>
<div class="paragraph">
<p>So, what will fail is clustering.</p>
</div>
<div class="sect2">
<h3 id="timeouts"><a class="anchor" href="#timeouts"></a>Timeouts</h3>
<div class="paragraph">
<p>There are 3 timeouts that can be configured.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Read operation: For any read-only operations: get, contains, getAll, iterator step (default: 5 seconds)</p>
</li>
<li>
<p>Write operation: For any write operation: put, remove, putAll, removeAll, clear, putIfAbsent, remove, replace (default: 5 seconds)</p>
</li>
<li>
<p>Connection: When establishing connection to the server (default: 150 seconds)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Timeouts can be configured using a dedicated builder or in XML.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight nowrap"><code class="language-java" data-lang="java">CacheManagerBuilder&lt;PersistentCacheManager&gt; clusteredCacheManagerBuilder =
  CacheManagerBuilder.newCacheManagerBuilder()
    .with(ClusteringServiceConfigurationBuilder.cluster(URI.create("terracotta://localhost/my-application"))
      .timeouts(TimeoutsBuilder.timeouts() <i class="conum" data-value="1"></i><b>(1)</b>
        .read(Duration.ofSeconds(10)) <i class="conum" data-value="2"></i><b>(2)</b>
        .write(Timeouts.DEFAULT_OPERATION_TIMEOUT) <i class="conum" data-value="3"></i><b>(3)</b>
        .connection(Timeouts.INFINITE_TIMEOUT)) <i class="conum" data-value="4"></i><b>(4)</b>
      .autoCreate());</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Start setting timeouts using the build</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Set the read timeout to 10 seconds</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Set the write timeout to the default. This line could actually be skipped since that&#8217;s what the builder will set it to anyway</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Set the connection timeout to be infinite</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="lease"><a class="anchor" href="#lease"></a>Lease</h3>
<div class="paragraph">
<p>A client establishes a lease with the server. A lease is a contract between the client and the server.
It means the server can&#8217;t make a change without getting the client acknowledgment.</p>
</div>
<div class="paragraph">
<p>The client takes care of renewing the lease before it expires.
The connection is closed by one of the two parties if it fails to do so.
As soon as this happens, <a href="tiering.html">caching tiers</a> are cleared.
The resilience strategy will then start answering every call.</p>
</div>
<div class="paragraph">
<p>By default, a lease lasts 150 seconds.
It is decided by the server and can be overridden in the server configuration.</p>
</div>
</div>
<div class="sect2">
<h3 id="reconnect"><a class="anchor" href="#reconnect"></a>Reconnect</h3>
<div class="paragraph">
<p>When a client gets disconnected, it will try to reconnect periodically.
As soon as it manages to reconnect, it will resume operation.
The caching tier will start filling again.</p>
</div>
<div class="paragraph">
<p>This should rarely occur in a production environment.
It generally means there was a network failure that cuts the client from its server.
It won&#8217;t occur if the active server goes down since we are expecting a failover to a mirror.</p>
</div>
</div>
</div>
</div>